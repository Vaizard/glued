var Authenticator;(()=>{"use strict";var e={d:(t,o)=>{for(var s in o)e.o(o,s)&&!e.o(t,s)&&Object.defineProperty(t,s,{enumerable:!0,get:o[s]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t)},t={};(()=>{e.d(t,{default:()=>r});class o{static getAccessToken(){return localStorage.getItem("access_token")}static getRefreshToken(){return localStorage.getItem("refresh_token")}static getIDToken(){return localStorage.getItem("id_token")}static setAccessToken(e){o.setLocalStorage("access_token",e)}static setRefreshToken(e){o.setLocalStorage("refresh_token",e)}static setIDToken(e){o.setLocalStorage("id_token",e)}static setLocalStorage(e,t){null!==t?localStorage.setItem(e,t):localStorage.removeItem(e)}static generateVerifierChallenge(){return crypto.randomBytes(32).toString("hex")}static getVerifierToken(){let e=localStorage.getItem("verifier_token");return e||(e=o.generateVerifierChallenge(),localStorage.setItem("verifier_token",e)),e}}class s{static saveState(e,t){localStorage.setItem("state_"+e,t)}static popState(e){let t=localStorage.getItem("state_"+e);return localStorage.removeItem("state_"+e),t}}class n{constructor(e){this.message=e,this.name="AuthenticationException"}}const r=class{constructor(e){if(!e?.tokenEndpoint||!e?.authorizationEndpoint)throw"At least tokenEndpoint and authorizationEndpoint needs to be configured";this.options=e}authenticatedFetch=async(e,t)=>{(t=this.injectBearer(t)).mode="cors";let o=await fetch(e,t);return 403!==o.status&&401!==o.status||(await this.refreshTokens(),t=this.injectBearer(t),o=await fetch(e,t)),o};injectBearer(e){e||(e={});let t=o.getAccessToken();return t?(e.headers||(e.headers={}),e.headers.Authorization="Bearer "+t,e):e}refreshTokens=async()=>{let e=await fetch(this.options.tokenEndpoint,{body:new URLSearchParams({client_id:this.options.clientId,refresh_token:o.getRefreshToken(),grant_type:"refresh_token"}),headers:{"Content-Type":"application/x-www-form-urlencoded"},method:"POST"});await this.handleCodeResponse(e)};getRedirectUri=()=>this.options.redirectUri??window.location;getPostLogoutUri=()=>this.options.logoutRedirectUri??window.location;createState=()=>{let e=Math.floor(1e6*Math.random());return s.saveState(e,this.getRedirectUri()),e};initiateLogin=()=>{let e=new URLSearchParams({client_id:this.options.clientId,redirect_uri:this.getRedirectUri(),response_type:"code",state:this.createState(),scope:this.options?.scope??"openid"});window.location=this.options.authorizationEndpoint+"?"+e};initiateEndSession=(e=null)=>{let t=new URLSearchParams({post_logout_redirect_uri:this.getPostLogoutUri(),redirect_uri:this.getPostLogoutUri()});null!==e&&t.set("id_token_hint",e),window.location=this.options.endSessionEndpoint+"?"+t};checkLogin=async()=>{let e=new URLSearchParams(window.location.search);if(e.has("code")){let t=await fetch(this.options.tokenEndpoint,{body:new URLSearchParams({client_id:this.options.clientId,code:e.get("code"),grant_type:"authorization_code",redirect_uri:s.popState(e.get("state"))}),headers:{"Content-Type":"application/x-www-form-urlencoded"},method:"POST"}),o=await this.handleCodeResponse(t);return this.removeAuthUrlParameters(),{success:!0,...o}}return{success:!1}};handleCodeResponse=async e=>{if(e.ok){let t=await e.json();return o.setAccessToken(t.access_token),o.setRefreshToken(t.refresh_token),t.id_token&&o.setIDToken(t.id_token),{accessToken:t.access_token,refreshToken:t.refresh_token}}{let t=await e.text();throw console.error(t),new n(t)}};logout=async()=>{if(!o.getAccessToken())return void console.warn("No session was ended because there was no session to end.");let e=o.getIDToken();o.setIDToken(null),o.setRefreshToken(null),o.setAccessToken(null),this.options.endSessionEndpoint?this.initiateEndSession(e):console.warn("Session was ended only locally, because no endSessionEndpoint is configured!")};removeAuthUrlParameters=()=>{let e=new URL(window.location);e.searchParams.delete("state"),e.searchParams.delete("code"),history.replaceState(null,"",e.href)}}})(),Authenticator=t.default})();